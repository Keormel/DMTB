# Полный гайд работы с графами - Логика кода

## Содержание
1. [Основные понятия](#основные-понятия)
2. [Структура класса Graph](#структура-класса-graph)
3. [Внутреннее представление](#внутреннее-представление)
4. [Методы работы с графами](#методы-работы-с-графами)
5. [Преобразования между представлениями](#преобразования-между-представлениями)
6. [Примеры использования](#примеры-использования)

---

## Основные понятия

### Что такое граф?
**Граф** - это структура данных, состоящая из:
- **Вершин (узлов)** - точки в графе (V)
- **Рёбер** - связи между вершинами (E)

### Типы графов
1. **Неориентированный граф** - рёбра не имеют направления
   - Если есть ребро A-B, то существует и B-A
   - Связь двусторонняя
   
2. **Ориентированный граф** - рёбра имеют направление
   - Ребро A→B не означает B→A
   - Связь односторонняя

### Примеры
```
Неориентированный:        Ориентированный:
    1 --- 2                   1 ---> 2
    |     |                   |      |
    3 --- 4                   v      v
                              3      4

Рёбра: (1,2), (1,3),      Рёбра: (1,2), (1,3),
       (2,4), (3,4)               (2,4), (3,4)
```

---

## Структура класса Graph

### Объявление класса
```python
@dataclass
class Graph:
    directed: bool = False
    adj: List[Set[int]] = field(default_factory=list)
```

### Атрибуты
| Атрибут | Тип | Описание |
|---------|-----|---------|
| `directed` | bool | true = ориентированный, false = неориентированный |
| `adj` | List[Set[int]] | **Основное представление**: список смежности |

### Свойство n
```python
@property
def n(self) -> int:
    return len(self.adj)
```
Возвращает количество вершин в графе.

---

## Внутреннее представление

### Список смежности - основное хранилище

**Определение**: Для каждой вершины хранится множество её соседей.

**Структура:**
```python
adj: List[Set[int]] = [
    {1, 2},      # Вершина 0 соединена с вершинами 1 и 2
    {0, 3},      # Вершина 1 соединена с вершинами 0 и 3
    {0, 3},      # Вершина 2 соединена с вершинами 0 и 3
    {1, 2}       # Вершина 3 соединена с вершинами 1 и 2
]
```

**Преимущества:**
- ✅ Экономна по памяти: O(V + E)
- ✅ Быстрый доступ к соседям: O(1)
- ✅ Эффективна для разреженных графов

**Пример графа с 4 вершинами:**
```
    0 --- 1
    |     |
    2 --- 3

adj[0] = {1, 2}
adj[1] = {0, 3}
adj[2] = {0, 3}
adj[3] = {1, 2}
```

---

## Методы работы с графами

### 1. Инициализация графа

#### `init_empty(n: int) -> None`
**Назначение**: Создать пустой граф с n вершинами без рёбер.

**Логика:**
```python
def init_empty(self, n: int) -> None:
    self.adj = [set() for _ in range(n)]
```

**Пример:**
```python
graph = Graph(directed=False)
graph.init_empty(4)  # 4 вершины, 0 рёбер
# graph.adj = [{}, {}, {}, {}]
```

---

### 2. Добавление ребра

#### `add_edge(u: int, v: int) -> None`
**Назначение**: Добавить ребро между вершинами u и v.

**Логика:**
```python
def add_edge(self, u: int, v: int) -> None:
    if not (0 <= u < self.n and 0 <= v < self.n):
        return
    self.adj[u].add(v)
    if not self.directed and u != v:  # Если неориентированный и не петля
        self.adj[v].add(u)             # Добавляем обратное ребро
```

**Пример неориентированного графа:**
```python
graph = Graph(directed=False)
graph.init_empty(3)
graph.add_edge(0, 1)  # Связываем вершины 0 и 1

# После add_edge(0, 1):
# adj[0] = {1}  ← добавили 1
# adj[1] = {0}  ← автоматически добавили обратное
```

**Пример ориентированного графа:**
```python
graph = Graph(directed=True)
graph.init_empty(3)
graph.add_edge(0, 1)  # Ребро только из 0 в 1

# После add_edge(0, 1):
# adj[0] = {1}  ← добавили 1
# adj[1] = {}   ← НИЧЕГО не добавилось (ориентированный)
```

**Обработка петель:**
```python
graph.add_edge(0, 0)  # Петля на вершине 0
# Неориентированный:
#   adj[0] = {0}  ← добавляется один раз благодаря set()
# Ориентированный:
#   adj[0] = {0}
```

---

### 3. Удаление ребра

#### `remove_edge(u: int, v: int) -> None`
**Назначение**: Удалить ребро между вершинами u и v.

**Логика:**
```python
def remove_edge(self, u: int, v: int) -> None:
    if not (0 <= u < self.n and 0 <= v < self.n):
        return
    self.adj[u].discard(v)
    if not self.directed and u != v:
        self.adj[v].discard(u)
```

**Пример:**
```python
graph.remove_edge(0, 1)
# adj[0] удаляем 1: {1} → {}
# adj[1] удаляем 0: {0} → {}
```

---

### 4. Нормализация графа

#### `normalize() -> None`
**Назначение**: Гарантировать, что неориентированный граф имеет симметричный список смежности.

**Проблема:**
Если добавить ребро в ориентированный граф, а потом переключить тип на неориентированный, список смежности может быть несинхронизирован.

**Логика:**
```python
def normalize(self) -> None:
    if self.directed:
        return
    for u in range(self.n):
        for v in list(self.adj[u]):
            self.adj[v].add(u)  # Добавляем обратное ребро везде
```

**Пример:**
```python
# Ориентированный граф с рёбрами:
# adj[0] = {1}
# adj[1] = {}

# Переключили на неориентированный
graph.directed = False
graph.normalize()

# После нормализации:
# adj[0] = {1}
# adj[1] = {0}  ← добавилось обратное ребро
```

---

## Преобразования между представлениями

### Представления графа

**Граф может быть представлен 4 способами:**

```
    0 --- 1
    |     |
    2 --- 3

1. Список смежности:      3. Матрица инцидентности:
   0: [1, 2]                 V\E  0  1  2  3
   1: [0, 3]                 0    1  1  0  0
   2: [0, 3]                 1    1  0  1  0
   3: [1, 2]                 2    1  0  0  1
                             3    0  1  0  1
2. Матрица смежности:
   0  1  0  1              4. Список рёбер:
   1  0  1  0                 [0-1, 0-2, 1-3, 2-3]
   0  1  0  1
   1  0  1  0
```

---

### 1. Матрица смежности

#### `to_adj_matrix() -> List[List[int]]`
**Назначение**: Преобразовать список смежности в матрицу смежности.

**Определение**: Матрица N×N, где M[i][j] = 1 если есть ребро (i,j), иначе 0.

**Логика:**
```python
def to_adj_matrix(self) -> List[List[int]]:
    n = self.n
    mat = [[0] * n for _ in range(n)]  # Создаём N×N матрицу нулей
    
    for u in range(n):
        for v in self.adj[u]:          # Для каждого соседа u
            mat[u][v] = 1              # Устанавливаем mat[u][v] = 1
    
    # Для неориентированного графа - синхронизируем
    if not self.directed:
        for i in range(n):
            for j in range(n):
                if mat[i][j] or mat[j][i]:
                    mat[i][j] = mat[j][i] = 1
    
    return mat
```

**Пошаговый пример:**
```python
# Исходный граф:
# adj[0] = {1, 2}
# adj[1] = {0}
# adj[2] = {0}

# Шаг 1: Создаём матрицу 3×3 из нулей
mat = [[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]]

# Шаг 2: Заполняем по списку смежности
# u=0: для v в {1,2}: mat[0][1]=1, mat[0][2]=1
# u=1: для v в {0}:   mat[1][0]=1
# u=2: для v в {0}:   mat[2][0]=1

mat = [[0, 1, 1],
       [1, 0, 0],
       [1, 0, 0]]

# Шаг 3: Если неориентированный - синхронизируем
# Результат:
mat = [[0, 1, 1],
       [1, 0, 0],
       [1, 0, 0]]
```

**Сложность:**
- Время: O(N²)
- Память: O(N²)

---

#### `from_adj_matrix(mat: List[List[int]], directed: bool) -> Graph`
**Назначение**: Создать граф из матрицы смежности.

**Логика:**
```python
@staticmethod
def from_adj_matrix(mat: List[List[int]], directed: bool) -> Graph:
    n = len(mat)
    g = Graph(directed=directed)
    g.init_empty(n)
    
    for i in range(n):
        for j in range(n):
            if mat[i][j] != 0:      # Если есть ребро
                g.add_edge(i, j)    # Добавляем его
    
    g.normalize()
    return g
```

**Пример:**
```python
mat = [[0, 1, 1],
       [1, 0, 0],
       [1, 0, 0]]

graph = Graph.from_adj_matrix(mat, directed=False)

# После обработки:
# adj[0] = {1, 2}
# adj[1] = {0}
# adj[2] = {0}
```

---

### 2. Матрица инцидентности

#### `to_incidence() -> List[List[int]]`
**Назначение**: Преобразовать граф в матрицу инцидентности (V×E).

**Определение**: 
- Матрица размером V (вершины) × E (рёбра)
- M[v][e] показывает связь вершины v с ребром e

**Значения для неориентированного графа:**
- 0: вершина не инцидентна ребру
- 1: вершина инцидентна ребру
- 2: петля (ребро из вершины в саму себя)

**Значения для ориентированного графа:**
- 0: вершина не инцидентна ребру
- -1: ребро выходит из вершины
- +1: ребро входит в вершину

**Логика:**
```python
def to_incidence(self) -> List[List[int]]:
    V = self.n
    edges = self.to_edge_list()      # Получаем список всех рёбер
    E = len(edges)
    mat = [[0] * E for _ in range(V)]
    
    for e, (u, v) in enumerate(edges):
        if self.directed:
            mat[u][e] = -1           # Ребро из u
            mat[v][e] = 1            # Ребро в v
        else:
            if u == v:
                mat[u][e] = 2        # Петля
            else:
                mat[u][e] = 1        # Инцидентна первая вершина
                mat[v][e] = 1        # Инцидентна вторая вершина
    
    return mat
```

**Пошаговый пример (неориентированный граф):**
```
Граф: 0 --- 1
      |     |
      2 --- 3

Рёбра: 0=(0,1), 1=(0,2), 2=(1,3), 3=(2,3)

Матрица инцидентности:
V\E  0  1  2  3
0    1  1  0  0   (вершина 0: инцидентна рёбрам 0 и 1)
1    1  0  1  0   (вершина 1: инцидентна рёбрам 0 и 2)
2    0  1  0  1   (вершина 2: инцидентна рёбрам 1 и 3)
3    0  0  1  1   (вершина 3: инцидентна рёбрам 2 и 3)

Проверка:
- Ребро 0=(0,1): в столбце 0 единицы в строках 0 и 1 ✓
- Ребро 1=(0,2): в столбце 1 единицы в строках 0 и 2 ✓
- Ребро 2=(1,3): в столбце 2 единицы в строках 1 и 3 ✓
- Ребро 3=(2,3): в столбце 3 единицы в строках 2 и 3 ✓
```

---

### 3. Список рёбер

#### `to_edge_list() -> List[Tuple[int, int]]`
**Назначение**: Получить список всех рёбер в графе.

**Логика:**
```python
def to_edge_list(self) -> List[Tuple[int, int]]:
    edges: List[Tuple[int, int]] = []
    
    if self.directed:
        # Ориентированный: просто берём все рёбра
        for u in range(self.n):
            for v in sorted(self.adj[u]):
                edges.append((u, v))
    else:
        # Неориентированный: избегаем дубликатов
        seen = set()
        for u in range(self.n):
            for v in sorted(self.adj[u]):
                a, b = (u, v) if u <= v else (v, u)
                if (a, b) not in seen:
                    seen.add((a, b))
                    edges.append((a, b))
    
    return edges
```

**Пошаговый пример (неориентированный):**
```python
# Граф:
# adj[0] = {1, 2}
# adj[1] = {0, 3}
# adj[2] = {0, 3}
# adj[3] = {1, 2}

# Обработка:
# u=0: v in {1,2} → (0,1), (0,2)
# u=1: v in {0,3} → (0,1) - дубликат, пропускаем; (1,3)
# u=2: v in {0,3} → (0,2) - дубликат; (2,3)
# u=3: v in {1,2} → (1,3) - дубликат; (2,3) - дубликат

# Результат: [(0,1), (0,2), (1,3), (2,3)]
```

**Сложность:**
- Время: O(V + E)
- Память: O(E)

---

### 4. Список смежности

#### `to_adj_list() -> List[List[int]]`
**Назначение**: Преобразовать внутреннее представление (Set) в List для вывода.

**Логика:**
```python
def to_adj_list(self) -> List[List[int]]:
    return [sorted(list(s)) for s in self.adj]
```

**Пример:**
```python
# Внутри:
# adj[0] = {2, 1}  (множество, порядок не гарантирован)

# После to_adj_list():
# [[1, 2], ...]  (список, отсортирован)
```

---

#### `from_adj_list(adj_list: List[List[int]], directed: bool) -> Graph`
**Назначение**: Создать граф из списка смежности.

**Логика:**
```python
@staticmethod
def from_adj_list(adj_list: List[List[int]], directed: bool) -> Graph:
    n = len(adj_list)
    g = Graph(directed=directed)
    g.init_empty(n)
    
    for u in range(n):
        for v in adj_list[u]:
            g.add_edge(u, v)
    
    g.normalize()
    return g
```

---

## Примеры использования

### Пример 1: Создание простого графа

```python
# Создаём неориентированный граф с 4 вершинами
graph = Graph(directed=False)
graph.init_empty(4)

# Добавляем рёбра
graph.add_edge(0, 1)  # 0 --- 1
graph.add_edge(0, 2)  # 0 --- 2
graph.add_edge(1, 3)  # 1 --- 3
graph.add_edge(2, 3)  # 2 --- 3

# Граф выглядит так:
#     0 --- 1
#     |     |
#     2 --- 3

print(graph.to_adj_list())
# [[1, 2], [0, 3], [0, 3], [1, 2]]
```

---

### Пример 2: Преобразования

```python
# Начинаем со списка смежности
adj_list = [[1, 2], [0, 3], [0, 3], [1, 2]]
graph = Graph.from_adj_list(adj_list, directed=False)

# Преобразуем в матрицу смежности
matrix = graph.to_adj_matrix()
print("Матрица смежности:")
for row in matrix:
    print(row)
# [0, 1, 1, 0]
# [1, 0, 0, 1]
# [1, 0, 0, 1]
# [0, 1, 1, 0]

# Преобразуем в список рёбер
edges = graph.to_edge_list()
print("Рёбра:", edges)
# [(0, 1), (0, 2), (1, 3), (2, 3)]

# Преобразуем в матрицу инцидентности
incidence = graph.to_incidence()
print("Матрица инцидентности:")
for row in incidence:
    print(row)
# [1, 1, 0, 0]
# [1, 0, 1, 0]
# [0, 1, 0, 1]
# [0, 0, 1, 1]
```

---

### Пример 3: Работа с ориентированным графом

```python
# Ориентированный граф: 0→1, 0→2, 1→3
graph = Graph(directed=True)
graph.init_empty(4)

graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 3)

# Список смежности
print(graph.to_adj_list())
# [[1, 2], [3], [], []]

# Матрица смежности
matrix = graph.to_adj_matrix()
# [0, 1, 1, 0]
# [0, 0, 0, 1]
# [0, 0, 0, 0]
# [0, 0, 0, 0]

# Рёбра
edges = graph.to_edge_list()
# [(0, 1), (0, 2), (1, 3)]
```

---

### Пример 4: Переключение типа графа

```python
# Начинаем с ориентированного
graph = Graph(directed=True)
graph.init_empty(3)
graph.add_edge(0, 1)
graph.add_edge(1, 2)

print("Ориентированный:")
print(graph.to_adj_list())
# [[1], [2], []]

# Переключаемся на неориентированный
graph.directed = False
graph.normalize()

print("Неориентированный (после нормализации):")
print(graph.to_adj_list())
# [[1], [0, 2], [1]]
```

---

### Пример 5: Работа с петлями

```python
graph = Graph(directed=False)
graph.init_empty(3)

# Добавляем обычное ребро
graph.add_edge(0, 1)

# Добавляем петлю (вершина связана сама с собой)
graph.add_edge(1, 1)

# Добавляем ещё одно ребро
graph.add_edge(1, 2)

print("Список смежности:")
print(graph.to_adj_list())
# [[1], [0, 1, 2], [1]]
#        ↑ петля

print("\nМатрица инцидентности:")
incidence = graph.to_incidence()
for row in incidence:
    print(row)
# [1, 0, 0]
# [1, 2, 1]  ← вторая вершина инцидентна петле (значение 2)
# [0, 0, 1]
```

---

## Краткая справка по сложности

### Временная сложность операций

| Операция | Сложность | Примечание |
|----------|-----------|-----------|
| `init_empty(n)` | O(n) | Создание пустого графа |
| `add_edge(u, v)` | O(1) | Добавление в множество |
| `remove_edge(u, v)` | O(1) | Удаление из множества |
| `normalize()` | O(V + E) | Синхронизация неориентированного |
| `to_adj_matrix()` | O(N²) | Заполнение матрицы |
| `to_edge_list()` | O(V + E) | Перечисление рёбер |
| `to_incidence()` | O(V × E) | Заполнение матрицы V×E |

### Пространственная сложность

| Представление | Память | Примечание |
|---------------|--------|-----------|
| Список смежности | O(V + E) | Оптимально для разреженных |
| Матрица смежности | O(V²) | Оптимально для плотных |
| Матрица инцидентности | O(V × E) | Зависит от количества рёбер |
| Список рёбер | O(E) | Минимум памяти |

---

## Алгоритмические вопросы

### Когда использовать какое представление?

**Список смежности:**
- ✅ Разреженные графы (мало рёбер)
- ✅ Нужен доступ к соседям вершины
- ✅ BFS/DFS алгоритмы

**Матрица смежности:**
- ✅ Плотные графы (много рёбер)
- ✅ Нужна быстрая проверка наличия ребра
- ✅ Матричные алгоритмы (Floyd-Warshall)

**Матрица инцидентности:**
- ✅ Анализ рёбер
- ✅ Сетевые потоки
- ✅ Поиск компонент связности

**Список рёбер:**
- ✅ Алгоритмы Крускала, Прима
- ✅ Минимальное остовное дерево
- ✅ Когда порядок вершин не важен

---

## Практические замечания

### Зачем нужна нормализация?

При смене типа графа с ориентированного на неориентированный может возникнуть несинхронизация:

```python
# Плохо:
graph = Graph(directed=True)
graph.init_empty(2)
graph.add_edge(0, 1)  # Только 0→1

graph.directed = False  # Переключились
# Теперь adj[0] = {1}, но adj[1] = {} ← БЕЗ обратного ребра!

# Хорошо:
graph.directed = False
graph.normalize()  # Синхронизируем
# Теперь adj[0] = {1}, adj[1] = {0} ✓
```

### Почему Set для список смежности?

1. **Быстрость**: O(1) проверка наличия ребра
2. **Дублирование**: Автоматически избегаем рёбер-дубликатов
3. **Удаление**: Быстрое удаление O(1)

```python
# Set автоматически избегает дубликатов
adj = set()
adj.add(1)
adj.add(1)  # Не добавляется
adj.add(1)  # Не добавляется
print(adj)  # {1}  - только один элемент!
```

---

## Заключение

Этот код реализует универсальный класс для работы с графами, поддерживающий:
- ✅ Ориентированные и неориентированные графы
- ✅ 4 основных представления
- ✅ Преобразования между представлениями
- ✅ Сохранение и загрузку через JSON
- ✅ Эффективное хранение (список смежности)

Логика основана на стандартных алгоритмах теории графов и оптимальна для большинства приложений.
